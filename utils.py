import argparse
import pickle

from matplotlib import pyplot as plt
import numpy as np
from sklearn import metrics

DATA_DIR = 'dataset'
MODEL_DIR = 'model'
DATASET_FILENAME = 'my_dataset_3000.csv'
TYPE_INDEX_RANGES = {
    'ByteHistorgram': (0, 255), # 256
    'ByteEntropyHistorgram': (256, 511), # 256
    'StringExtractor': (512, 615), # 104
    'GeneralFileInfo': (616, 625), # 10
    'HeaderFileInfo': (626, 687), # 62
    'SectionInfo': (688, 942), # 255
    'ImportsInfo': (943, 2222), # 1280
    'ExportsInfo': (2223, 2350), # 128
    'DataDirectories': (2351, 2380), #30
}
SELECTION_GROUP_FEATURES = [
    'ByteHistorgram',
    'ByteEntropyHistorgram',
    'StringExtractor',
    'GeneralFileInfo',
    'HeaderFileInfo',
    'SectionInfo',
    'ImportsInfo',
    'ExportsInfo',
    'DataDirectories'
]

def parse_arguments():
    """
    Parse command line arguments.

    Returns:
        argparse.Namespace: Parsed arguments.
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('--selection_group_features', nargs="*", type=str, default=[], choices=SELECTION_GROUP_FEATURES)
    parser.add_argument('--data_dir', type=str, default=DATA_DIR)
    parser.add_argument('--model_dir', type=str, default=MODEL_DIR)
    parser.add_argument('--dataset_filename', type=str, default=DATASET_FILENAME, choices=[
        'my_dataset_3000.csv',
        'my_dataset_4000.csv',
        'my_dataset_5000.csv', 
        'my_dataset_10000.csv',
        'my_dataset_20000.csv',
    ])
    parser.add_argument('--top_n_labels', type=int, default=-1)
    parser.add_argument('--is_binary', type=int, choices=[0,1], default=0)
    return parser.parse_args()

def get_X(df, selection_group_features):
    """
    Get X from selection_group_features, df.

    Args:
        df (pandas.DataFrame): Input dataframe.
        selection_group_features (list): List of selected features.

    Returns:
        pandas.DataFrame: Filtered dataframe containing the selected features.
    """
    if len(selection_group_features) == 0:
        return df[df.columns.tolist()[:-1]]
    raw_features_names = df.columns.tolist()[:-1] # the last column is the label
    filtered_features = filter_features(raw_features_names, selection_group_features, TYPE_INDEX_RANGES)
    X = df[filtered_features]
    return X

def filter_features(raw_features_names, selection_group_features, type_index_ranges):
    """
    Filter out features based on their type and index range.

    Args:
        raw_features_names (list): List of all feature names.
        selection_group_features (list): List of selected feature types.
        type_index_ranges (dict): Dictionary mapping feature types to index ranges.

    Returns:
        list: Filtered list of feature names.
    """
    filtered_features = []
    for feature in selection_group_features:
        start, end = type_index_ranges[feature]
        filtered_features.extend(raw_features_names[start:end+1])
    return filtered_features

def plot_confusion_matrix(models, X_test, y_test, classes, title='Confusion matrix', cmap=plt.cm.Blues):
    # Plot in 1 fig with multiple subfigs
    fig, axes = plt.subplots(3, 3, figsize=(15, 15))
    for i, (name, model) in enumerate(models):
        ax = axes[i//3, i%3]
        y_pred = model.predict(X_test)
        cm = metrics.confusion_matrix(y_test, y_pred)
        plot_confusion_matrix_subfig(cm, classes, ax, title=f'{name} - Confusion matrix')

    plt.tight_layout()
    plt.show()

def plot_confusion_matrix_subfig(cm, classes, ax, title='Confusion matrix', cmap=plt.cm.Blues):
    ax.imshow(cm, interpolation='nearest', cmap=cmap)
    ax.set_title(title)
    tick_marks = np.arange(len(classes))
    ax.set_xticks(tick_marks)
    ax.set_xticklabels(classes, rotation=45)
    ax.set_yticks(tick_marks)
    ax.set_yticklabels(classes)

    for i in range(len(classes)):
        for j in range(len(classes)):
            ax.text(j, i, cm[i, j], horizontalalignment='center', color='white' if cm[i, j] > cm.max() / 2 else 'black')

    ax.set_ylabel('True label')
    ax.set_xlabel('Predicted label')

def plot_roc_curve(fpr, tpr, roc_auc):
    plt.figure()
    plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc)
    plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.05])
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic')
    plt.legend(loc='lower right')
    plt.show()

def save_model(model, model_filename):
    with open(model_filename, 'wb') as model_file:
        pickle.dump(model, model_file)

def load_model(model_filename):
    with open(model_filename, 'rb') as model_file:
        model = pickle.load(model_file)
    return model

def get_top_labels(df, count):
    if count < 0:
        return df
    top_labels = df['label'].value_counts().nlargest(count).index.tolist()
    return df[df['label'].isin(top_labels)]

def get_metrics(model, X_test, y_test, labels):
    y_pred = model.predict(X_test)
    accuracy = metrics.accuracy_score(y_test, y_pred)
    f1 = metrics.f1_score(y_test, y_pred, average='weighted', labels=labels, zero_division=1)
    precision = metrics.precision_score(y_test, y_pred, average='micro', labels=labels, zero_division=1)
    recall = metrics.recall_score(y_test, y_pred, average='weighted', labels=labels, zero_division=1)

    # confusion matrix of model
    cm = metrics.confusion_matrix(y_test, y_pred, labels=labels)

    return {
        'accuracy': accuracy,
        'f1': f1,
        'precision': precision,
        'recall': recall,
        'confusion_matrix': cm
    }

def camel_to_snake(name):
    return ''.join(['_' + c.lower() if c.isupper() else c for c in name]).lstrip('_')