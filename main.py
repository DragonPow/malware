# Importing necessary libraries
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
import time
import os
import pandas as pd
from sklearn.naive_bayes import BernoulliNB, GaussianNB, MultinomialNB
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier
import utils
from sklearn import metrics

def main():
    # Assign command line arguments to variables
    args = utils.parse_arguments()
    selection_group_features = args.selection_group_features
    data_dir = args.data_dir
    model_dir = args.model_dir
    file_name = args.dataset_filename
    top_n_labels = args.top_n_labels
    is_binary = args.is_binary

    # build testcase name from args
    # convert selection_group_features from AbdDef to abd_def
    name_testcase_group_feature = '_'.join([utils.camel_to_snake(feature) for feature in selection_group_features])
    testcase_name = f"{name_testcase_group_feature or 'all_feature'}_{top_n_labels if top_n_labels != -1 else 'all_label'}_{'binary' if is_binary else 'multi'}"
    print(f'Testcase name: {testcase_name}')
    # Build the path to the dataset file
    file_csv = os.path.join(data_dir, file_name)

    # Read dataset from a file
    df = pd.read_csv(file_csv, sep='|')
    print(df.shape)
    print('Read dataset successfully')
    if is_binary:
        # convert all label not NaN to 1, else 0
        df['label'] = df['label'].apply(lambda x: 1 if pd.notnull(x) else 0)
    else:
        # convert label NaN to 'benign'
        df['label'] = df['label'].fillna('benign')
        # get top n labels
        df = utils.get_top_labels(df, top_n_labels)

    X = utils.get_X(df, selection_group_features)
    y = df['label']

    # Split the dataset into training and testing sets
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # list models is common classifier mode, with naive bayes, random forest, svm, knn, decision tree
    models = [
        ('gaussian_bayes', GaussianNB()),
        ('bernoulli_bayes', BernoulliNB()),
        # ('Multinomial Bayes', MultinomialNB()),
        ('random_forest', RandomForestClassifier(n_estimators=100)),
        ('svm', SVC()),
        ('knn', KNeighborsClassifier()),
        ('decision_tree', DecisionTreeClassifier())
    ]

    # using pipeline to train and test model
    print('\nSTART TRAINING AND TESTING MODELS')
    print('-'*20 + '\n')
    for name, model in models:
        print(f'Running {name} model')
        start = time.time()
        model.fit(X_train, y_train)
        end = time.time()
        print(f'{name} - Training time: {end - start} seconds')

        start = time.time()
        score = model.score(X_test, y_test)
        end = time.time()
        print(f'{name} - Testing time: {end - start} seconds')

        # get metrics of model: accuracy, f1_score, precision, recall using lib metrics
        m = utils.get_metrics(model, X_test, y_test)

        try:
            if is_binary:
                # curve of model
                y_pred_proba = model.predict_proba(X_test)[:, 1]
                fpr, tpr, _ = metrics.roc_curve(y_test, y_pred_proba)
                roc_auc = metrics.auc(fpr, tpr)
        except Exception as e:
            print(f'Error when calculate roc_auc: {e}')
            roc_auc = None
            fpr = None
            tpr = None

        # store all value need to metrics, compute, compare,...
        data_store = {
            'training_time': end - start,
            'testing_time': end - start,
            'metrics': m,
            'roc_auc': roc_auc if is_binary else None,
            'fpr': fpr if is_binary else None,
            'tpr': tpr if is_binary else None
        }

        # Save the model to disk
        model_file = os.path.join(model_dir, f'{testcase_name}_{name}.pkl')
        datasources_file = os.path.join(model_dir, f'{testcase_name}_{name}_datasources.pkl')
        utils.save_model(model, model_file)
        utils.save_model(data_store, datasources_file)
        print(f'Saved model to {model_file}')
        print('-'*20 + '\n')

    # classes = df['label'].unique()
    # Plot confusion matrix, using utils.plot_confusion_matrix
    # utils.plot_confusion_matrix(models, X_test, y_test, classes, title=f'{name} - Confusion matrix')
        
if __name__ == '__main__':
    main()